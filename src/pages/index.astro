---
import Connector from '../components/Connector.astro'
import LinkCard from '../components/LinkCard.astro'
import { domain, subDomains, subRoutes } from '../libs/consts'
---

<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Astro</title>
  </head>
  <body>
    <div class="container">
      <h1 id="domain">ras0q.com</h1>

      {
        subDomains.map((d, i) => (
          <>
            <div
              id={`subdomain_${i}`}
              class="draggable"
              style={{
                position: 'fixed',
                top: `${10 + (90 * i) / subDomains.length}%`,
                left: '10%',
              }}
            >
              <LinkCard title={d.name} body={d.description} href={`https://${d.name}.${domain}`} />
            </div>
            <Connector start={`subdomain_${i}`} end="domain" />
          </>
        ))
      }

      {
        subRoutes.map((r, i) => (
          <>
            <Connector start="domain" end={`subpath_${i}`} />
            <div
              id={`subpath_${i}`}
              class="draggable"
              style={{
                position: 'fixed',
                top: `${10 + (90 * i) / subRoutes.length}%`,
                right: '10%',
              }}
            >
              <LinkCard title={r.path} body={r.description} href={r.path} />
            </div>
          </>
        ))
      }
    </div>
  </body>
</html>

<style>
  .container {
    > h1 {
      font-size: 5rem;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      -webkit-transform: translate(-50%, -50%);
      -ms-transform: translate(-50%, -50%);
    }
  }
</style>

<script>
  const insideParentX = (el: HTMLElement, left: number) => {
    return left >= 0 && left + el.offsetWidth <= window.innerWidth
  }

  const insideParentY = (el: HTMLElement, top: number) => {
    return top >= 0 && top + el.offsetHeight <= window.innerHeight
  }

  document.querySelectorAll<HTMLElement>('.draggable').forEach((el) => {
    el.addEventListener('pointermove', (e) => {
      if (e.buttons === 1) {
        const left = el.offsetLeft + e.movementX
        const top = el.offsetTop + e.movementY
        if (!insideParentX(el, left) || !insideParentY(el, top)) return

        el.style.left = `${left}px`
        el.style.top = `${top}px`
        el.style.position = 'fixed'
        el.draggable = false
        el.setPointerCapture(e.pointerId)

        // save last movement for inertia
        el.dataset.lastMovementX = e.movementX.toString()
        el.dataset.lastMovementY = e.movementY.toString()
      }
    })

    el.addEventListener('pointerup', (e) => {
      el.releasePointerCapture(e.pointerId)

      // inertia
      let vx = parseInt(el.dataset.lastMovementX!)
      let vy = parseInt(el.dataset.lastMovementY!)
      const inertia = 0.9
      const friction = 1
      const interval = setInterval(() => {
        if (Math.abs(vx) < friction && Math.abs(vy) < friction) {
          clearInterval(interval)
        } else {
          vx *= inertia
          vy *= inertia
          const left = el.offsetLeft + vx
          const top = el.offsetTop + vy
          insideParentX(el, left) ? (el.style.left = `${left}px`) : (vx *= -1)
          insideParentY(el, top) ? (el.style.top = `${top}px`) : (vy *= -1)
        }
      }, 1000 / 60)
    })
  })
</script>
